#!/usr/bin/env python3
# encoding: UTF-8

# This file is part of Addison Arches.
#
# Addison Arches is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Addison Arches is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Addison Arches.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import datetime
import itertools
import operator
import pathlib
import random
import sys

import pkg_resources

__doc__ = """
Create new dialogue files from a template,  directories, and some names.
Generates Python code to describe them as SceneScripts in an episode.

Eg::

    templotter.py --dir bluemonday78/dialogue/ep_?? \
        --template bluemonday78/utils/template.rst \
        begin end >> bluemonday78/logic.py

"""

DEFAULT_LOCATION = "."
DEFAULT_FORMAT = "{name}"
DEFAULT_SUFFIX = ".rst"

DEFAULT_NAMES = [
    "about", "always", "approach", "ante", "action", "aside", "angel", "attack",
    "aria",
    "beforehand", "backstory", "beginning", "bargain", "betterment", "bother",
    "birth", "battle", "background",
    "character", "creation", "challenge", "collect", "coronation", "credo",
    "curtain", "caring", "common", "comedy",
    "domestic", "daily", "duty", "deliberate", "dally", "doom", "details",
    "death", "done", "dominate", "drama",
    "episode", "eviction", "emphasis", "epilogue", "ending", "enter", "exit",
    "funny", "forwards", "failure", "freedom", "false", "fade", "forever",
    "found",
    "gravity", "gain", "gap", "greeting", "grave", "grievous", "gist", "given",
    "habit", "hero", "herald", "hope", "help", "history", "honour",
    "initiate", "impediment", "inspiration", "insert", "interlude"
    "joke", "jolt", "justice", "jettison", "jump", "jester", "juvenile",
    "kill", "kettle", "kicker", "knock", "knackered", "knight", "knowledge",
    "launch", "loop", "light", "law", "lore", "laughter", "little", "legend",
    "libretto",
    "misery", "manage", "mayhem", "mission", "middle", "me", "murder",
    "narrative", "neglect", "notice", "neighbour", "nominate", "nearby", "no",
    "nemesis", "notices",
    "obvious", "outwitted", "outside", "otherwise", "old", "obsolete",
    "practice", "portal", "problem", "present", "picture", "pantomime", "peril",
    "pretence", "protest", "persona", "prologue", "promise", "precis",
    "questions", "quarry", "queue", "quarrel",
    "reversal", "return", "reminder", "refusal", "reveal", "right", "routine",
    "rhyme", "rhythm", "rumour", "role", "ruling", "recitative", "reward",
    "scare", "success", "shock", "shatter", "suddenly", "slowly", "shade",
    "service", "set", "sink", "source", "summary",
    "together", "tragedy", "tension", "test", "triumph", "taken", "true",
    "technique", "technical", "them", "theatre", "thrown",
    "tradition", "thanks",
    "ulterior", "ultimate", "unknown", "ugly", "unify", "ultimiatum",
    "victory", "vanquished", "veil", "valuables", "verify", "validation",
    "war", "worry", "welcome", "wishes", "wrong", "wandering", "wonder",
    "whenever", "wave",
    "xit", "xellence", "xeunt", "xtraction", "xpiation",
    "yes", "yesterday", "you", "yet", "yonder",
    "zero", "zig", "zag", "zigzag", "zen", "zeal", "zenith"
]

DEFAULT_TEMPLATE = """{name}
"""

EPISODE_HEADER = """
import decimal
import itertools
from turberfield.dialogue.model import SceneScript

...

episodes = [
"""

SCENESCRIPT_TEMPLATE = """
    SceneScript.Folder(
        pkg="p_k_g",
        description="Generated by templotter.",
        metadata={{
            "episode": decimal.Decimal({n_drcty}),
        }},
        paths=[
{files}
        ],
        interludes=itertools.repeat(None)
    ),
"""

def pick_one(names):
    names = sorted(names)
    print("", file=sys.stderr)
    print(
        *["{0}: {1}".format(n + 1, name) for n, name in enumerate(names)],
        sep="\n", file=sys.stderr
    )
    print("0: SKIP".format(len(names)), file=sys.stderr)
    print("=> ", end="", file=sys.stderr)
    choice = input()
    try:
        return None if not int(choice) else names[int(choice) - 1]
    except (IndexError, ValueError):
        return None

def generate_names(picker):
    for group, names in itertools.groupby(DEFAULT_NAMES, key=operator.itemgetter(0)):
        name = picker(list(names))
        if name is not None:
            yield name

def main(args):
    picker = pick_one if args.pick else random.choice
    names = args.names or generate_names(picker)
    template = args.template.read() if args.template else DEFAULT_TEMPLATE
    if args.dirs and names:
        print(EPISODE_HEADER, file=sys.stdout)
    for n_drcty, drcty in enumerate(args.dirs):
        files = []
        for n, name in enumerate(names):
            basename = args.format.format(n, name=name)
            path = pathlib.Path(drcty).expanduser().joinpath(basename).with_suffix(args.suffix)
            path.touch()
            scene = "{0}\n{1}".format(name, "~" * len(name))
            path.write_text(template.format(
                name=name, scene=scene, dir=drcty, path=path.resolve(),
                today=datetime.date.today()
            ))
            files.append(path.resolve().relative_to(
                pkg_resources.resource_filename("p_k_g", "")
            ))

        print(
            SCENESCRIPT_TEMPLATE.rstrip().format(
                files=",\n".join('{0}"{1}"'.format(" " * 12, i) for i in files),
                n_drcty=n_drcty
            ).rstrip(),
            file=sys.stdout
        )
    if args.dirs and names:
        print("]", file=sys.stdout)
    return 0

def parser(description=__doc__):
    rv = argparse.ArgumentParser(
        description,
        fromfile_prefix_chars="@"
    )
    rv.add_argument(
        "--pick", default=False, action="store_true",
        help="interactively pick each name"
    )
    rv.add_argument(
        "--dirs", default=[DEFAULT_LOCATION], nargs="+",
        help="set a location for the new files [{0}]".format(DEFAULT_LOCATION)
    )
    rv.add_argument(
        "--format", default=DEFAULT_FORMAT, required=False,
        help="format string for each file name ['{0}']".format(DEFAULT_FORMAT)
    )
    rv.add_argument(
        "--suffix", default=DEFAULT_SUFFIX, required=False,
        help="add a suffix after each file name ['{0}']".format(DEFAULT_SUFFIX)
    )
    rv.add_argument(
        "--template", type=argparse.FileType("r"), required=False,
        help="define a template for new file content"
    )
    rv.add_argument("names", nargs="*", help="supply a list of file names")
    return rv


if __name__ == "__main__":
    p = parser()
    args = p.parse_args()
    rv = main(args)
    sys.exit(rv)
